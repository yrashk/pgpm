#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "pgpm"
require "dry/cli"
require "parallel"

module Pgpm
  module CLI
    module Commands
      extend Dry::CLI::Registry

      class Version < Dry::CLI::Command
        desc "Print version"

        def call(*)
          puts Pgpm::VERSION
        end
      end

      class Build < Dry::CLI::Command
        desc "Build packages"

        option :os, type: :string, default: Pgpm::OS.auto_detect.name, desc: "OS name"
        option :arch, type: :string, default: Pgpm::Arch.host.name, desc: "Target architecture"
        option :pgdist, type: :string, default: "pgdg", desc: "Target Postgres distribution"
        option :pgver, type: :string, default: Pgpm::Postgres::Distribution.versions.last.to_s, desc: "Target Postgres version"
        argument :packages, type: :array, required: true, desc: "Package names"

        # rubocop:disable Metrics/ParameterLists:
        def call(packages:, args: nil, os: nil, arch: nil, pgdist: nil, pgver: nil)
          _ = args
          _ = os
          _ = pgdist

          # puts "There is no build support for OS distribution `#{os}`"
          # exit(1)
          pkgs = Parallel.flat_map(packages) do |package|
            name, version = package.split("@")
            version ||= :latest
            p = Pgpm::Package[name]
            if p.nil?
              puts "Package #{name} not found"
              exit(1)
            end
            if p.contrib?
              puts "Can't build a contrib package"
              exit(1)
            end
            pkg = p[version]
            if pkg.nil?
              puts "Package #{name} with version #{version} not found"
              exit(1)
            end
            pkg
          end

          os = Pgpm::OS.auto_detect
          arch = if arch
                   Pgpm::Arch.new(arch)
                 else
                   Pgpm::Arch.host
                 end

          pgver = Package::Version.new(pgver)
          matching_pgver = Postgres::Distribution.versions.find { |v| v.satisfies?(">= #{pgver}") && v.satisfies?("< #{pgver.major + 1}") }
          unless matching_pgver
            puts "#{pgver} is not a known Postgres version"
            exit(1)
          end

          puts "Building for Postgres #{matching_pgver}"
          selected_pgdist = Postgres::RedhatBasedPgdg.new(matching_pgver.to_s)

          os.with_scope do
            arch.with_scope do
              selected_pgdist.with_scope do
                b = pkgs.reduce(nil) do |c, p|
                  if p.broken?
                    puts "Can't build a broken package #{p.name}@#{p.version}"
                    exit(1)
                  end
                  p = Pgpm::ScopedObject.new(p, os, arch)
                  spec = p.to_rpm_spec
                  builder = Pgpm::RPM::Builder.new(spec)
                  src_builder = builder.source_builder
                  p = c.nil? ? src_builder : c.and_then(src_builder)
                  p.and_then(builder.versionless_builder)
                end

                srpms = b.call
                Pgpm::RPM::Builder.builder(srpms).call
              end
            end
          end
        end

        # rubocop:enable Metrics/ParameterLists:
      end

      class Search < Dry::CLI::Command
        argument :query, type: :string, default: ".*", desc: "Search query"

        def call(query:, args: nil)
          _ = args
          query_regexp = Regexp.new(query, "i")
          Parallel.filter_map(Pgpm::Package) do |p|
            next if p.contrib?

            matches = p.all_searchable_texts.any? do |t|
              t =~ query_regexp
            end
            "#{p.package_name}: #{p.description}" if matches
          end.each { |l| puts l }
        end
      end

      register "version", Version, aliases: ["v", "-v", "--version"]
      register "build", Build
      register "search", Search
    end
  end
end

Pgpm.load_packages(File.join(Dir.pwd, "packages"))
Dry::CLI.new(Pgpm::CLI::Commands).call
